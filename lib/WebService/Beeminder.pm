package WebService::Beeminder;

# ABSTRACT: Access the Beeminder API

use 5.010;
use strict;
use warnings;
use MooseX::Method::Signatures;
use Moose;
use JSON::Any;
use LWP::UserAgent;
use Carp qw(croak);

# VERSION: Generated by DZP::OurPkg:Version

has 'token'   => (isa => 'Str', is => 'ro', required => 1);
has 'username'=> (isa => 'Str', is => 'ro', default => 'me');
has 'agent'   => (              is => 'rw'); # Must act like LWP::UserAgent
has 'dryrun'  => (isa => 'Bool',is => 'ro', default => 0);
has 'apibase' => (isa => 'Str', is => 'ro', default => 'https://www.beeminder.com/api/v1'); 

# Everything needs to be able to read/write JSON.
my $json = JSON::Any->new;

sub BUILD {
    my ($self) = @_;

    # Make sure we have a user-agent, if none provided.
    if (not $self->agent) {
        $self->agent(LWP::UserAgent->new(agent => "perl/$], WebService::Beeminder/" . $self->VERSION));
    }

    return;
}

# Get information about a user
method user(Str $user = "me") {

    # AFAIK, the $user here is irrelevant, since we can only query
    # the user we're logged in as. Still, we'll respect it, in
    # case that changes in the future.

    return $self->_get('users',"$user.json");

}

# Gets the datapoints for a goal
# DONE: 2011-11-25. This takes no parameters.
method datapoints(Str $goal) {
    return $self->_userget( 'goals', $goal, 'datapoints.json');
}

method add_datapoint(
    Str  :$goal!,
    Int  :$timestamp,     # TODO: Change to a proper timestamp type.
    Num  :$value!,
    Str  :$comment = "",
    Bool :$sendmail = 0
) {
    $timestamp //= time();

    return $self->_userpost( 
        { timestamp => $timestamp, value => $value, comment => $comment, sendmail => $sendmail },
        'goals', $goal, 'datapoints.json' 
    );
}

# Posts to the API. Takes a hashref of parameters. Remaining arguments
# are interpreted as a path.
sub _userpost {
    my ($self, $params, @path) = @_;

    my $url  = $self->_path('users', $self->username, @path);

    my $resp = $self->agent->post( $url, $params );

    unless ($resp->is_success) { 
        croak "Failed to fetch $url - ".$resp->status_line; 
    }

    return $json->decode($resp->content);

};

# Builds a path, and adds appropriate auth tokens, etc.
sub _path {
    my ($self, @path) = @_;

    my $url  = join('/', $self->apibase, @path) . "?auth_token=" . $self->token;

    if ($self->dryrun) {
        $url .= "&dryrun=1";
    }
    
    return $url;
}

# Fetches something from the API. Automatically prepends the API path,
# adds the token to the end, and decodes the JSON.

sub _get {
    my ($self, @path) = @_;

    my $url  = $self->_path(@path);
    my $resp = $self->agent->get( $url );

    unless ($resp->is_success) { 
        croak "Failed to fetch $url - ".$resp->status_line; 
    }

    return $json->decode($resp->content);
}

# As for _get, but prepends 'users' and the current user.
sub _userget {
    my ($self, @args) = @_;

    return $self->_get('users', $self->username, @args);
}

1;
